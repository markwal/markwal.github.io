{"version":3,"sources":["webpack://encrusted/./node_modules/wasm-ffi/src/Wrapper.js","webpack://encrusted/./node_modules/wasm-ffi/src/demangle.js","webpack://encrusted/./node_modules/wasm-ffi/src/encoding.js","webpack://encrusted/./node_modules/wasm-ffi/src/misc.js","webpack://encrusted/./node_modules/wasm-ffi/src/types.js","webpack://encrusted/webpack/bootstrap","webpack://encrusted/webpack/runtime/define property getters","webpack://encrusted/webpack/runtime/hasOwnProperty shorthand","webpack://encrusted/./node_modules/wasm-ffi/src/Struct.js","webpack://encrusted/./node_modules/wasm-ffi/src/rust.js","webpack://encrusted/./node_modules/wasm-ffi/src/assemblyscript.js","webpack://encrusted/./node_modules/wasm-ffi/src/index.js","webpack://encrusted/./src/js/worker.js"],"names":["numbers","Set","areValid","argTypes","every","type","has","isStruct","isPointer","fs","fetch_polyfill","file","Promise","resolve","reject","eval","replace","readFile","err","data","arrayBuffer","ok","fetchFn","fetch","fetchAndInstantiate","url","imports","then","resp","Error","status","headers","get","WebAssembly","instantiateStreaming","buf","instantiate","result","instance","DATA","Symbol","for","Wrapper","signatures","opts","dialect","toLowerCase","this","allocations","Map","memory","debug","isAssemblyScript","Object","entries","forEach","fn","returnType","name","arg","add","fnName","utils","encodeString","__encodeString","bind","decodeString","__decodeString","readStringView","__readStringView","readString","__readString","writeString","__writeString","writeArray","__writeArray","readStruct","__readStruct","writeStruct","__writeStruct","readPointer","__readPointer","writePointer","__writePointer","allocate","value","ref","free","__free","exports","importArg","applyDefaults","wrap","fnConfig","pop","Array","isArray","args","ffi_args","map","i","__out","length","push","slice","__in","env","print","str","console","log","eprint","error","trace","abort","msg","line","col","errCode","exitCode","obj","assign","__link","Instance","__wrap","stack","ptr","JSON","stringify","size","deallocate","set","optSize","delete","start","DataView","buffer","encoded","len","byteLength","Uint8Array","ArrayBuffer","header","setUint32","view","subarray","__view","getUint32","end","__allocate","isView","arr","StructType","width","read","Type","constructor","write","ptrType","pointer","wrapper","addr","commit","cwrap","use","ccall","call","symbols","replaceAllSymbols","reduce","re","char","demangleStack","split","_","m1","m2","mangled","startsWith","sub","indexOf","inner","chars","labels","label","digits","test","parseInt","join","demangle","encodeUTF8","codePoint","leadSurrogate","units","Infinity","bytes","charCodeAt","from","decodeUTF8","pts","firstByte","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","String","fromCharCode","j","encode","Uint16Array","encodeUTF16","TextEncoder","decode","num","byteOffset","decodeUTF16","TextDecoder","assert","condition","errMsg","strings","e","part","vslice","toUint8Array","isNil","thing","prop","prototype","hasOwnProperty","isFunction","addStringFns","StringLike","getOwnPropertyNames","addArrayFns","ArrayLike","values","makeIterable","iterator","next","done","CustomType","isNaN","alignment","SignedInteger","UnsignedInteger","types","int8","int16","int32","uint8","uint16","uint32","int64","uint64","float","getFloat32","setFloat32","double","getFloat64","setFloat64","bool","getInt8","setInt8","Pointer","parseType","_temp","deref","typedef","StringPointer","_tempStr","_tempBuf","_width","defineProperty","enumerable","string","ArrayType","subview","aliases","u8","u16","u32","u64","i8","i16","i32","i64","f32","f64","uchar","schar","short","ushort","int","uint","long","ulong","longlong","ulonglong","size_t","usize","parseTypeString","__webpack_module_cache__","__webpack_require__","moduleId","module","__webpack_modules__","d","definition","key","o","fields","opt","names","temp","internal","freePointers","struct","field","out","proto","offset","fieldView","packed","RustTuple","tupleTypes","Tuple","RustVector","initialValues","Base","cap","arrayType","Vector","super","RustSlice","Slice","RustString","RustStr","RustOption","isNonNullable","tagSize","discriminant","OptionType","isSome","defaultValue","tuple","vector","enum","variants","vtypes","Enum","variant","_set","keys","tag","arms","val","field_1","field_2","Math","max","t","align","option","some","none","Str","Option","Some","None","wasmURL","process","sendWorkerMessage","postMessage","zmachine","create","feed","step","undo","redo","get_updates","restore","load_savestate","enable_instruction_logs","get_object_details","rust","flush_log","js_message","setTimeout","rand","floor","random","onmessage","ev","catch","file_ptr"],"mappings":"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","file":"worker.js","sourcesContent":["import { Pointer, StringPointer } from './types';\nimport { encode, decode } from './encoding';\nimport { assert, isNil, toUint8Array } from './misc';\nimport demangle from './demangle';\n\n\nconst numbers = new Set([\n  'int8', 'int16', 'int32', 'int64',\n  'uint8', 'uint16', 'uint32', 'uint64',\n  'float', 'double',\n  'u8', 'u16', 'u32', 'u64',\n  'i8', 'i16', 'i32', 'i64',\n  'f32', 'f64',\n  'schar', 'short', 'int', 'long',\n  'char', 'uchar', 'ushort', 'uint', 'ulong',\n  'size_t',\n  'usize',\n]);\n\n\nfunction areValid(argTypes) {\n  return argTypes.every(type =>\n    type === null ||\n    type === undefined ||\n    type === 'void' ||\n    type === 'number' ||\n    type === 'boolean' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type === 'array' ||\n    numbers.has(type) ||\n    type.isStruct ||\n    type.isPointer);\n}\n\n\n// a node fetch polyfill that won't trigger webpack\n// idea borrowed from:\n// https://github.com/dcodeIO/webassembly/blob/master/src/index.js#L223\nlet fs;\nfunction fetch_polyfill(file) {\n  return new Promise((resolve, reject) => {\n    (fs || (fs = eval('equire'.replace(/^/, 'r'))('fs'))).readFile(\n      file,\n      function(err, data) {\n        return (err)\n          ? reject(err)\n          : resolve({\n              arrayBuffer: () => Promise.resolve(data),\n              ok: true,\n            });\n      }\n    );\n  });\n}\n\n\nconst fetchFn = (typeof fetch === 'function' && fetch) || fetch_polyfill;\n\n\n// gets the wasm at a url and instantiates it.\n// checks if streaming instantiation is available and uses that\nfunction fetchAndInstantiate(url, imports) {\n  return fetchFn(url)\n    .then((resp) => {\n      if (!resp.ok) {\n        throw new Error(`Got a ${resp.status} fetching wasm @ ${url}`);\n      }\n\n      const wasm = 'application/wasm';\n      const type = resp.headers && resp.headers.get('content-type');\n\n      return (WebAssembly.instantiateStreaming && type === wasm)\n        ? WebAssembly.instantiateStreaming(resp, imports)\n        : resp.arrayBuffer().then(buf => WebAssembly.instantiate(buf, imports));\n    })\n    .then(result => result.instance);\n}\n\n\nconst DATA = (typeof Symbol !== 'undefined')\n  ? Symbol.for('wrapper-data')\n  : '__data';\n\n\nclass Wrapper {\n  constructor(signatures, opts = {}) {\n    const dialect = opts.dialect && opts.dialect.toLowerCase();\n\n    // Keep internal info behind the DATA symbol so wrapped function names\n    // won't cause conflicts\n    this[DATA] = {\n      instance: null,\n      imports: null,\n      signatures: new Set(),\n      allocations: new Map(),\n      memory: opts.memory,\n      debug: !!opts.debug,\n      isAssemblyScript: dialect === 'assemblyscript',\n    };\n\n    Object.entries(signatures).forEach(([fn, [returnType, argTypes = []]]) => {\n      // check for name collisions:\n      ['exports', 'imports', 'utils', 'fetch', 'use'].forEach(name =>\n        assert(fn !== name, '`%s` is a reserved wrapper name', name));\n\n      // validate arg types\n      assert(argTypes.every(arg => !!arg), '`%s` has undefined types', fn);\n      assert(areValid([returnType]), '`%s` has invalid types', fn);\n      assert(areValid(argTypes), '`%s` has invalid types', fn);\n\n      this[DATA].signatures.add({ fnName: fn, returnType, argTypes });\n    });\n\n    // exposing some methods via `.utils`\n    this.utils = {\n      encodeString:   this.__encodeString.bind(this),\n      decodeString:   this.__decodeString.bind(this),\n      readStringView: this.__readStringView.bind(this),\n      readString:     this.__readString.bind(this),\n      writeString:    this.__writeString.bind(this),\n      writeArray:     this.__writeArray.bind(this),\n      readStruct:     this.__readStruct.bind(this),\n      writeStruct:    this.__writeStruct.bind(this),\n      readPointer:    this.__readPointer.bind(this),\n      writePointer:   this.__writePointer.bind(this),\n\n      allocate: function(value) {\n        assert(typeof value.ref === 'function',\n          \"Can't allocate '%s' This method is for Pointer & Structs\", value);\n\n        (value instanceof Pointer || value instanceof StringPointer)\n          ? this.__writePointer(value)\n          : this.__writeStruct(value);\n      }.bind(this),\n\n      free: function(value) {\n        (typeof value.ref === 'function')\n          ? this.__free(value.ref())\n          : this.__free(value);\n      }.bind(this),\n    };\n\n    this.exports = null;\n  }\n\n  // takes an import object or a function what will produce a import object\n  imports(importArg, applyDefaults = true) {\n    const wrap = (...fnConfig) => {\n      // function to wrap is always the last argument\n      const fn = fnConfig.pop();\n      // two argument formats (this might be a bad idea):\n      //   1) with return type: wrap([returnType, [...argTypes]], fn)\n      //   2) no return type: wrap(arg1, arg2, ..., fn)\n      //\n      // detructure into appropriate vars\n      const [returnType, argTypes = []] = (Array.isArray(fnConfig[0]))\n        ? fnConfig[0]       // 1st format\n        : [null, fnConfig]; // 2nd format\n\n      assert(areValid(argTypes), `Import has invalid types: ${argTypes}`);\n      assert(areValid([returnType]), `Import has invalid types: ${returnType}`);\n\n      return (...args) => {\n        const ffi_args = argTypes.map((type, i) => this.__out(args[i], type));\n\n        if (args.length > argTypes.length) {\n          ffi_args.push(...args.slice(argTypes.length - args.length));\n        }\n\n        const value = fn(...ffi_args);\n\n        if (returnType && returnType !== 'void') {\n          return this.__in(value, returnType);\n        }\n      };\n    };\n\n    const env = {\n      // wasm-glue\n      print:  wrap('string', (str, ...args) => console.log(str, ...args)),\n      eprint: wrap('string', (str, ...args) => console.error(str, ...args)),\n      trace:  wrap('string', (str) => { throw new Error(str); }),\n\n      // assemblyscript\n      abort: wrap('string', 'string', 'number', 'number', (msg, file, line, col) => {\n        throw new Error(`${msg} @ ${file}:${line}:${col}`);\n      }),\n\n      // <webassembly.h>\n      _abort(errCode) {\n        throw new Error(`Aborting, error code: ${errCode}`);\n      },\n\n      _exit(exitCode) {\n        if (exitCode) throw new Error(`Exit error code: ${exitCode}`);\n      },\n\n      _grow() {},\n    };\n\n    const obj = (typeof importArg === 'function')\n      ? importArg(wrap)\n      : importArg;\n\n    if (applyDefaults) obj.env = Object.assign(env, obj.env);\n    this[DATA].imports = obj;\n\n    return obj;\n  }\n\n  fetch(url) {\n    const imports = this[DATA].imports || this.imports({});\n\n    return fetchAndInstantiate(url, imports).then((instance) => {\n      this.__link(instance);\n      return this;\n    });\n  }\n\n  use(instance) {\n    assert(instance instanceof WebAssembly.Instance,\n      '.use(instance) requires a WebAssembly.Instance');\n\n    this.__link(instance);\n    return this;\n  }\n\n  __link(instance) {\n    const memory = this[DATA].memory ||\n                   instance.exports.memory ||\n                   (this[DATA].imports.env && this[DATA].imports.env.memory);\n\n    assert(!!memory, '' +\n      'Wrapper needs access to your WebAssemmbly memory. It looks for this in' +\n      'either your `imports.env.memory` or `exports.env.memory`. If you don\\'t' +\n      'use either, you need to add it in the options with `new Wrapper`');\n\n    this.exports = instance.exports;\n    this[DATA].instance = instance;\n    this[DATA].memory = memory;\n\n    this[DATA].signatures.forEach(({ fnName, returnType, argTypes }) => {\n      const fn = this.exports[fnName];\n      assert(!!fn, `Fn '${fnName}' missing from wasm exports`);\n\n      this[fnName] = this.__wrap(fn, argTypes, returnType);\n    });\n  }\n\n  __wrap(fn, argTypes, returnType) {\n    return function(...args) {\n      const stack = [];\n      const ffi_args = argTypes.map((type, i) => this.__in(args[i], type, stack));\n      let value;\n\n      if (args.length > argTypes.length) {\n        ffi_args.push(...args.slice(argTypes.length - args.length));\n      }\n\n      try {\n        value = fn(...ffi_args);\n      } catch (err) {\n        throw demangle(err);\n      }\n\n      stack.forEach(ptr => this.__free(ptr));\n\n      if (returnType && returnType !== 'void') {\n        return this.__out(value, returnType);\n      }\n    };\n  }\n\n  // wrap a variable heading into a wasm function\n  __in(value, type, stack) {\n    assert(!!type, 'No arg type was specified for this function');\n\n    if (type === 'number' || numbers.has(type)) return value;\n    if (type === 'boolean' || type === 'bool') return !!value;\n    if (type === 'string') return this.__writeString(value, stack);\n    if (type === 'array') return this.__writeArray(value, stack);\n    if (type.isStruct) return this.__writeStruct(value, type);\n    if (type.isPointer) return this.__writePointer(value);\n\n    throw new Error(`Unknown type: \\n${JSON.stringify(type)}`);\n  }\n\n  // wrap a variable heading out of a wasm function\n  __out(value, type) {\n    assert(!!type, 'No arg type was specified for this function');\n\n    if (type === 'number' || numbers.has(type)) return value;\n    if (type === 'boolean' || type === 'bool') return !!value;\n    if (type === 'string') return this.__readString(value);\n    if (type.isStruct) return this.__readStruct(value, type);\n    if (type.isPointer) return this.__readPointer(value, type);\n\n    throw new Error(`Unknown type: \\n${JSON.stringify(type)}`);\n  }\n\n  __allocate(size) {\n    assert(!!this.exports.allocate && !!this.exports.deallocate,\n      \"Missing allocate/deallocate fns in wasm exports, can't allocate memory\");\n\n    const ptr = this.exports.allocate(size);\n    assert(!!ptr, 'allocate failed');\n\n    if (this[DATA].debug) console.log('Alloc: %s (size=%s)', ptr, size);\n    this[DATA].allocations.set(ptr, size);\n\n    return ptr;\n  }\n\n  __free(ptr, optSize) {\n    const size = optSize || this[DATA].allocations.get(ptr);\n    if (this[DATA].debug) console.log('Free: %s (size=%s)', ptr, size);\n\n    this.exports.deallocate(ptr, size);\n    this[DATA].allocations.delete(ptr);\n  }\n\n  __view(start, length) {\n    return new DataView(this[DATA].memory.buffer, start, length);\n  }\n\n  __encodeString(str) {\n    const encoded = (this[DATA].isAssemblyScript)\n      ? encode(str, 'utf-16')\n      : encode(str);\n\n    const len = (this[DATA].isAssemblyScript)\n      ? encoded.byteLength + 4  // assemblyscript header\n      : encoded.byteLength + 1; // null terminating byte\n\n    const buf = new Uint8Array(new ArrayBuffer(len));\n\n    if (this[DATA].isAssemblyScript) {\n      const header = encoded.byteLength / 2;\n      (new DataView(buf.buffer)).setUint32(0, header, true);\n      buf.set(encoded, 4);\n    } else {\n      buf.set(encoded, 0);\n      buf[len - 1] = 0;\n    }\n\n    return buf;\n  }\n\n  __decodeString(view) {\n    const buf = toUint8Array(view);\n\n    return (this[DATA].isAssemblyScript)\n      ? decode(buf.subarray(4), 'utf-16')\n      : decode(buf.subarray(0, -1));\n  }\n\n  __readStringView(ptr) {\n    // length prefixed\n    if (this[DATA].isAssemblyScript) {\n      const strlen = this.__view().getUint32(ptr, true); // header\n      const len = 4 + (strlen * 2);\n\n      return this.__view(ptr, len);\n    }\n\n    // null terminated\n    const memory = new Uint8Array(this[DATA].memory.buffer);\n\n    let end = ptr;\n    while (memory[end]) ++end;\n\n    return this.__view(ptr, (end - ptr + 1));\n  }\n\n  __readString(ptr) {\n    return this.__decodeString(this.__readStringView(ptr));\n  }\n\n  __writeString(str, stack) {\n    const buf = this.__encodeString(str);\n\n    const ptr = this.__allocate(buf.byteLength);\n    if (stack) stack.push(ptr);\n\n    const memory = new Uint8Array(this[DATA].memory.buffer);\n    memory.set(buf, ptr);\n\n    return ptr;\n  }\n\n  __writeArray(arg, stack) {\n    assert(arg instanceof ArrayBuffer || ArrayBuffer.isView(arg),\n      'Argument must be an ArrayBuffer or a TypedArray (like Uint8Array)');\n\n    const arr = (!ArrayBuffer.isView(arg)) ? new Uint8Array(arg) : arg;\n\n    const len = (this[DATA].isAssemblyScript)\n      ? arr.byteLength + 16 /* Array/ArrayBuffer header */\n      : arr.byteLength;\n\n    const ptr = this.__allocate(len);\n    if (stack) stack.push(ptr);\n\n    const memory = new Uint8Array(this[DATA].memory.buffer);\n    const data = toUint8Array(arr);\n\n    if (this[DATA].isAssemblyScript) {\n      this.__view().setUint32(ptr + 0, ptr + 8, true);        // arraybuffer ptr\n      this.__view().setUint32(ptr + 4, arr.length, true);     // array length\n      this.__view().setUint32(ptr + 8, arr.byteLength, true); // byteLength\n      memory.set(data, ptr + 16);                             // contents\n    } else {\n      memory.set(data, ptr);\n    }\n\n    return ptr;\n  }\n\n  __readStruct(ptr, StructType) {\n    assert(!!StructType, 'No struct StructType given');\n\n    const view = this.__view(ptr, StructType.width);\n    const struct = StructType.read(view, this.utils);\n\n    return struct;\n  }\n\n  __writeStruct(value, Type) {\n    // if struct has already been allocated:\n    if (!isNil(value) && value.ref && value.ref()) return value.ref();\n\n    const StructType = Type || value.constructor;\n    const ptr = this.__allocate(StructType.width);\n    const view = this.__view(ptr, StructType.width);\n\n    StructType.write(view, value, this.utils);\n\n    return ptr;\n  }\n\n  __readPointer(ptr, ptrType) {\n    assert(!!ptrType, 'No pointer type given');\n\n    // get the size of what the pointer points to\n    const view = this.__view(ptr, ptrType.type.width);\n\n    // handle pointer of a pointer cases (structs are pointers too here)\n    if (ptrType.type.isStruct || ptrType.type.isPointer) {\n      return ptrType.read(view, this.utils);\n    }\n\n    const pointer = new Pointer(ptrType.type);\n    pointer.view = view;\n    pointer.wrapper = this.utils;\n\n    return pointer;\n  }\n\n  __writePointer(pointer) {\n    if (pointer.ref()) return pointer.ref();\n\n    pointer.wrapper = this.utils;\n\n    // allocate space for what the pointer points to\n    const size = pointer.size();\n    const addr = this.__allocate(size);\n    const view = this.__view(addr, size);\n\n    pointer.view = view;\n    pointer.commit();\n\n    return addr;\n  }\n}\n\n\nfunction cwrap(instance, fnName, returnType = null, argTypes = []) {\n  assert(instance instanceof WebAssembly.Instance,\n    '.cwrap() requires a ready WebAssembly.Instance');\n\n  const wrapper = new Wrapper({ [fnName]: [returnType, argTypes] });\n  wrapper.use(instance);\n\n  return wrapper[fnName].bind(wrapper);\n}\n\nfunction ccall(instance, fnName, returnType = null, argTypes = [], ...args) {\n  assert(instance instanceof WebAssembly.Instance,\n    '.ccall() requires a ready WebAssembly.Instance');\n\n  const wrapper = new Wrapper({ [fnName]: [returnType, argTypes] });\n  wrapper.use(instance);\n\n  return wrapper[fnName].call(wrapper, ...args);\n}\n\n\nexport { Wrapper, cwrap, ccall };\n","// Rust demangle logic adpated from Alex Crichton's ructc-demangle:\n// http://alexcrichton.com/rustc-demangle/src/rustc_demangle/lib.rs.html\nconst symbols = [\n  [/^_\\$/, '$'],\n  [/\\$C\\$/g, ','],\n  [/\\$SP\\$/g, '@'],\n  [/\\$BP\\$/g, '*'],\n  [/\\$RF\\$/g, '&'],\n  [/\\$LT\\$/g, '<'],\n  [/\\$GT\\$/g, '>'],\n  [/\\$LP\\$/g, '('],\n  [/\\$RP\\$/g, ')'],\n  [/\\$u7e\\$/g, '~'],\n  [/\\$u20\\$/g, ' '],\n  [/\\$u27\\$/g, \"'\"],\n  [/\\$u5b\\$/g, '['],\n  [/\\$u5d\\$/g, ']'],\n  [/\\$u7b\\$/g, '{'],\n  [/\\$u7d\\$/g, '}'],\n  [/\\$u3b\\$/g, ';'],\n  [/\\$u2b\\$/g, '+'],\n  [/\\$u22\\$/g, '\"'],\n  [/\\.\\./g, '::'],\n];\n\nfunction isHash(str) {\n  return str.length &&\n    str[0] === 'h' &&\n    str.split('').slice(1).every(char => /[0-9a-f]/i.test(char));\n}\n\n// replaces all symbols in string, returning a new string\nfunction replaceAllSymbols(str) {\n  return symbols.reduce(\n    (result, [re, char]) => result.replace(re, char),\n    str\n  );\n}\n\n// Basic rust demangle rules:\n// - starts with \"ZN | _ZN | __ZN\" and ends in \"E\"\n// - name is made up of chunks. chunks are length prefixed\n//\n// Bails early if string isn't a valid rust mangle\n//\nfunction demangle(mangled = '') {\n  const startsWith = sub => mangled.indexOf(sub) === 0;\n  const endsWith = sub => mangled.slice(-1) === sub;\n  let inner;\n\n  if (!endsWith('E')) return mangled;\n\n  if (startsWith('ZN')) inner = mangled.slice(2, -1);\n  else if (startsWith('_ZN')) inner = mangled.slice(3, -1);\n  else if (startsWith('__ZN')) inner = mangled.slice(4, -1);\n\n  if (!inner) return mangled;\n\n  const chars = inner.split('');\n  const labels = [];\n  let label = '';\n  let digits = '';\n  let length = 0;\n\n  chars.forEach((char) => {\n    // add characters to label while length marker > 0\n    if (length) {\n      label += char;\n      length--;\n\n    // otherwise, this label is complete and we start on the next\n    } else {\n      if (label) {\n        labels.push(label);\n        label = '';\n      }\n\n      // build length prefix, one digit at a time until we hit non-digit\n      if (/[0-9]/.test(char)) {\n        digits += char;\n      } else {\n        length = parseInt(digits, 10); // parse # the collected string\n        digits = '';   // clear for next time\n        label += char; // add first char to label\n        length--;      // decrement\n      }\n    }\n  });\n\n  // make sure last label is included\n  labels.push(label);\n\n  // if the last element is a hash, exclude it so the result is more readable\n  if (isHash(labels.slice(-1)[0])) labels.pop();\n\n  // replace symbol markers in labels with the actual symbols before joining\n  return labels.map(replaceAllSymbols).join('::');\n}\n\n\n// Tries to demangle an error stack on an Error object.\n// Only demangles rust right now.\n//\nexport default function demangleStack(err) {\n  // matches error stack line patterns in chrome and firefox\n  // chrome: \"at function_name (...\"\n  // firefox: \"function_name @ ...\"\n  const re = /(?:at (.+) \\()|(?:(.+)<?@)/;\n\n  // replaces matches, if found, with the demangled identifier\n  err.stack = err.stack\n    .split('\\n')\n    .map(line => line.replace(re, (_, m1, m2) => `at ${demangle(m1 || m2)} (`))\n    .join('\\n');\n\n  return err;\n}\n","function encodeUTF16(str) {\n  const buf = new ArrayBuffer(str.length * 2); // 2 per char\n  const arr = new Uint16Array(buf);\n\n  for (let i = 0; i < str.length; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n\n  return new Uint8Array(buf);\n}\n\nfunction decodeUTF16(buf) {\n  const len = buf.byteLength;\n  const num = (len % 2) ? ((len + 1) / 2) : (len / 2);\n  const pts = new Uint16Array(buf.buffer, buf.byteOffset, num);\n\n  return String.fromCharCode(...pts);\n}\n\n// utf8 decode/encode adapted from the buffer module\n// @ github.com/feross/buffer\n//\nfunction encodeUTF8(str) {\n  let codePoint;\n  let leadSurrogate = null;\n  let units = Infinity;\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    codePoint = str.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n\n        } else if (i + 1 === str.length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return Uint8Array.from(bytes);\n}\n\n\nfunction decodeUTF8(buf) {\n  const start = 0; // view.byteOffset;\n  const end = buf.length;\n\n  const pts = [];\n  let i = start;\n\n  while (i < end) {\n    const firstByte = buf[i];\n    let codePoint = null;\n\n    let bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1;\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break;\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        default:\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      pts.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    pts.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n  // the lowest limit is Chrome, with 0x10000 args.\n  // We go 1 magnitude less, for safety\n  const MAX = 0x1000;\n\n  if (pts.length <= MAX) {\n    return String.fromCharCode.call(String, ...pts); // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let str = '';\n  let j = 0;\n\n  while (j < pts.length) {\n    str += String.fromCharCode.call(String, ...pts.slice(j, j += MAX));\n  }\n\n  return str;\n}\n\n\nfunction encode(str, type) {\n  if (type === 'utf-16') return encodeUTF16(str);\n\n  return (typeof TextEncoder !== 'undefined')\n    ? (new TextEncoder()).encode(str)\n    : encodeUTF8(str);\n}\n\n\nfunction decode(str, type) {\n  if (type === 'utf-16') return decodeUTF16(str);\n\n  return (typeof TextDecoder !== 'undefined')\n    ? (new TextDecoder()).decode(str)\n    : decodeUTF8(str);\n}\n\n\nexport { encode, decode, encodeUTF8, decodeUTF8 };\n","// simple assert, throws if assertion fails\n// also matches args to %s formatters\nexport function assert(condition, errMsg, ...args) {\n  if (condition) return;\n  if (!args || !args.length) throw new Error(errMsg);\n\n  let msg = '';\n  let strings;\n\n  try {\n    strings = args.map(arg => JSON.stringify(arg, null, 2));\n  } catch (e) {\n    throw new Error(errMsg);\n  }\n\n  errMsg.split('%s').forEach((part) => {\n    msg += part;\n    if (strings.length) msg += strings.pop();\n  });\n\n  throw new Error(msg);\n}\n\n\n// takes a subslice of a DataView\nexport function vslice(view, start, length) {\n  return new DataView(view.buffer, view.byteOffset + start, length);\n}\n\n\nexport function toUint8Array(arr) {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n\nexport function isNil(thing) {\n  return thing === null || typeof thing === 'undefined';\n}\n\n\nconst has = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nconst isFunction = thing => (typeof thing === 'function');\n\n\nexport function addStringFns(StringLike) {\n  assert(!!has(StringLike.prototype, 'value'), 'Missing `value` property');\n\n  Object.getOwnPropertyNames(String.prototype).forEach((prop) => {\n    if (has(StringLike.prototype, prop)) return;\n    if (!isFunction(String.prototype[prop])) return;\n\n    StringLike.prototype[prop] = function(...args) {\n      return this.value[prop](...args);\n    };\n  });\n}\n\n\nexport function addArrayFns(ArrayLike) {\n  assert(!!has(ArrayLike.prototype, 'values'), 'Missing `values` property');\n\n  Object.getOwnPropertyNames(Array.prototype).forEach((prop) => {\n    if (has(ArrayLike.prototype, prop)) return;\n    if (!isFunction(Array.prototype[prop])) return;\n\n    ArrayLike.prototype[prop] = function(...args) {\n      return this.values[prop](...args);\n    };\n  });\n}\n\n\nexport function makeIterable(ArrayLike) {\n  assert(!!has(ArrayLike.prototype, 'values'), 'Missing `values` property');\n  assert(!!has(ArrayLike.prototype, 'length'), 'Missing `length` property');\n\n  ArrayLike.prototype[Symbol.iterator] = function() {\n    const values = this.values;\n    const length = this.length;\n    let i = 0;\n\n    return {\n      next() {\n        return (i < length)\n          ? { value: values[i++], done: false }\n          : { done: true };\n      }\n    };\n  };\n}\n","import { assert, vslice, toUint8Array, addStringFns } from './misc';\n\n\n// Makes a type of a given size.\n// Optional read / write methods, just gives a DataView by default.\nclass CustomType {\n  constructor(size, opts = {}) {\n    assert(!isNaN(size), 'Type size must be a number, given: %s', size);\n\n    this.width = size;\n    this.alignment = ('alignment' in opts) ? opts.alignment : size;\n\n    if (opts.read) this.read = opts.read;\n    if (opts.write) this.write = opts.write;\n  }\n\n  read(view) {\n    return view;\n  }\n\n  write(view, value) {\n    assert(value instanceof ArrayBuffer || ArrayBuffer.isView(value),\n      'Value must be an `ArrayBuffer` or a `DataView` (like `Uint8Array`)');\n\n    toUint8Array(view).set(toUint8Array(value));\n  }\n}\n\n\nclass SignedInteger {\n  constructor(width) {\n    this.width = width;\n    this.alignment = width;\n\n    const get = `getInt${width * 8}`;\n    const set = `setInt${width * 8}`;\n\n    this.read = view => view[get](0, true /* little-endian */);\n    this.write = (view, value) => view[set](0, value, true /* little-endian */);\n  }\n}\n\n\nclass UnsignedInteger {\n  constructor(width) {\n    this.width = width;\n    this.alignment = width;\n\n    const get = `getUint${width * 8}`;\n    const set = `setUint${width * 8}`;\n\n    this.read = view => view[get](0, true /* little-endian */);\n    this.write = (view, value) => view[set](0, value, true /* little-endian */);\n  }\n}\n\n\nconst types = {};\n\ntypes.void = {\n  width: 0,\n  alignment: 0,\n  read: () => null,\n  write: () => {},\n};\n\ntypes.int8 = new SignedInteger(1);\ntypes.int16 = new SignedInteger(2);\ntypes.int32 = new SignedInteger(4);\ntypes.uint8 = new UnsignedInteger(1);\ntypes.uint16 = new UnsignedInteger(2);\ntypes.uint32 = new UnsignedInteger(4);\n\ntypes.int64 = new CustomType(8);\ntypes.uint64 = new CustomType(8);\n\ntypes.float = {\n  width: 4,\n  alignment: 4,\n\n  read(view) {\n    return view.getFloat32(0, true /* little-endian */);\n  },\n\n  write(view, value) {\n    view.setFloat32(0, value, true /* little-endian */);\n  },\n};\n\ntypes.double = {\n  width: 8,\n  alignment: 8,\n\n  read(view) {\n    return view.getFloat64(0, true /* little-endian */);\n  },\n\n  write(view, value) {\n    view.setFloat64(0, value, true /* little-endian */);\n  },\n};\n\ntypes.bool = {\n  width: 1,\n  alignment: 1,\n\n  read(view) {\n    return !!view.getInt8(0);\n  },\n\n  write(view, value) {\n    view.setInt8(0, (!!value) ? 1 : 0);\n  },\n};\n\n\n// A pointer to some other data type in memory\nclass Pointer {\n  constructor(type, value) {\n    this.type = parseType(type);\n    this.view = null;\n    this.wrapper = null;\n\n    this._temp = value;\n  }\n\n  size() {\n    return this.type.width;\n  }\n\n  commit() {\n    if (this._temp) {\n      this.type.write(this.view, this._temp, this.wrapper);\n    }\n  }\n\n  ref() {\n    return (this.view) ? this.view.byteOffset : 0;\n  }\n\n  deref() {\n    assert(this.view, 'Trying to deref an unallocated pointer');\n    return this.type.read(this.view, this.wrapper);\n  }\n\n  set(value) {\n    if (this.view) {\n      this.type.write(this.view, value, this.wrapper);\n    } else {\n      this._temp = value;\n    }\n  }\n\n  free() {\n    assert(this.view, 'Cant free pointer: unallocated / already freed');\n\n    this.wrapper.free(this.ref(), this.type.width);\n    this.view = null;\n  }\n\n  toString() {\n    return (this.ref())\n      ? `Pointer( ${this.deref()} )`\n      : 'Pointer( null )';\n  }\n}\n\ntypes.pointer = function(typedef) {\n  const type = parseType(typedef);\n\n  return {\n    type,\n    width: 4,\n    alignment: 4,\n    isPointer: true,\n\n    read(view, wrapper) {\n      const addr = view.getUint32(0, true /* little-endian */);\n      const data = new DataView(view.buffer, addr, type.width);\n\n      const pointer = new Pointer(type);\n      pointer.view = data;\n      pointer.wrapper = wrapper;\n\n      return pointer;\n    },\n\n    write(view, value, wrapper) {\n      assert(value instanceof Pointer, `Trying to write ${value} as a pointer`);\n\n      if (!value.ref()) wrapper.writePointer(value);\n      view.setUint32(0, value.ref(), true /* little-endian */);\n    },\n  };\n};\n\n\nclass StringPointer {\n  constructor(value) {\n    this.view = null;\n    this.wrapper = null;\n\n    this._tempStr = value;\n    this._tempBuf = null;\n    this._width = null;\n  }\n\n  size() {\n    this._tempBuf = this.wrapper.encodeString(this._tempStr);\n    this._width = this._tempBuf.byteLength;\n\n    return this._width;\n  }\n\n  commit() {\n    assert(!!this.view, 'Cant commit StringPointer, no view!');\n\n    if (this._tempBuf) {\n      const memory = new Uint8Array(this.view.buffer);\n      memory.set(this._tempBuf, this.view.byteOffset);\n    }\n  }\n\n  ref() {\n    return (this.view) ? this.view.byteOffset : 0;\n  }\n\n  deref() {\n    assert(this.view, 'Trying to deref an unallocated StringPointer');\n    return this.wrapper.decodeString(this.view);\n  }\n\n  free() {\n    assert(!!this.view, 'Cant free StringPointer: unallocated / already freed');\n    this.wrapper.free(this.ref(), this._width);\n    this.view = null;\n  }\n}\n\nObject.defineProperty(StringPointer.prototype, 'value', {\n  enumerable: true,\n\n  get() {\n    return this.deref();\n  },\n});\n\naddStringFns(StringPointer);\n\n\ntypes.string = {\n  width: 4,\n  alignment: 4,\n  isPointer: true,\n\n  read(view, wrapper) {\n    const addr = view.getUint32(0, true /* little-endian */);\n\n    const pointer =  new StringPointer();\n    pointer.view = wrapper.readStringView(addr);\n    pointer.wrapper = wrapper;\n\n    return pointer;\n  },\n\n  write(view, value, wrapper) {\n    if (typeof value === 'string') {\n      value = new StringPointer(value);\n    }\n\n    if (!value.ref()) wrapper.writePointer(value);\n    view.setUint32(0, value.ref(), true /* little-endian */);\n  },\n};\n\n\n// An array (of known size) of sub-types.\nclass ArrayType {\n  constructor(type, length) {\n    this.type = type;\n    this.length = length;\n\n    this.width = type.width * length;\n    this.alignment = type.alignment;\n  }\n\n  read(view, wrapper) {\n    const arr = [];\n\n    for (let i = 0; i <= this.length - 1; i++) {\n      const subview = vslice(view, i * this.type.width, this.type.width);\n      arr.push(this.type.read(subview, wrapper));\n    }\n\n    return arr;\n  }\n\n  write(view, values, wrapper) {\n    assert(values.length === this.length,\n      'Values length does not match struct array length');\n\n    values.forEach((value, i) => {\n      const subview = vslice(view, i * this.type.width, this.type.width);\n      this.type.write(subview, value, wrapper);\n    });\n  }\n}\n\n\n// Maps other names to base types\n//\n// Some questionable decisions:\n//  - char = uint8 (I mean, what do you do, really)\n//  - long = int32 (windows=32, linux=64, wasm is 32bit right now, so...)\n//\nconst aliases = {\n  u8: types.uint8,\n  u16: types.uint16,\n  u32: types.uint32,\n  u64: types.uint64,\n  i8: types.int8,\n  i16: types.int16,\n  i32: types.int32,\n  i64: types.int64,\n  f32: types.float,\n  f64: types.double,\n  char: types.uint8,\n  uchar: types.uint8,\n  schar: types.int8,\n  short: types.int16,\n  ushort: types.uint16,\n  int: types.int32,\n  uint: types.uint32,\n  long: types.int32,\n  ulong: types.uint32,\n  longlong: types.uint64,\n  ulonglong: types.uint64,\n  size_t: types.uint32,\n  usize: types.uint32,\n};\n\n\nfunction parseTypeString(str) {\n  const name = str.toLowerCase();\n\n  if (name in types) return types[name];\n  if (name in aliases) return aliases[name];\n\n  throw new Error(`Parsing unknown type '${str}'`);\n}\n\n\n// parse a type from some type definition.\n// may be a string, an actual type, or an array of types\nfunction parseType(typedef) {\n  if (typeof typedef === 'string') {\n    return parseTypeString(typedef);\n  }\n\n  if (Array.isArray(typedef)) {\n    assert(typedef.length === 2,\n      'Array type needs 2 arguments: [type, length], given: \\n%s', typedef);\n\n    const type = parseType(typedef[0]);\n    const length = typedef[1];\n\n    return new ArrayType(type, length);\n  }\n\n  // make sure its an ok type interface\n  const errMsg = \"Given argument type isn't a proper 'type' interface: \\n%s\";\n  assert('width' in typedef, errMsg, typedef);\n  assert('alignment' in typedef, errMsg, typedef);\n  assert('read' in typedef, errMsg, typedef);\n  assert('write' in typedef, errMsg, typedef);\n\n  return typedef;\n}\n\n\nexport { types, CustomType, Pointer, StringPointer, parseType };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","import { parseType } from './types';\nimport { assert, vslice, isNil } from './misc';\n\n\nconst DATA = (typeof Symbol !== 'undefined')\n  ? Symbol.for('struct-data')\n  : '__data';\n\n\nclass AbstractStructType {\n  constructor(obj) {\n    // structs can be made with any object keys\n    // hide internal info behind the data symbol so you can still have\n    // struct fields like `.view`\n    this[DATA] = {\n      temp: {},\n      view: null,\n      wrapper: null,\n    };\n\n    if (obj) {\n      Object.entries(obj).forEach(([key, value]) => {\n        assert(key in this, `Can't set value, struct missing field '${key}'`);\n        this[key] = value;\n      });\n    }\n  }\n\n  ref() {\n    return (this[DATA].view) ? this[DATA].view.byteOffset : 0;\n  }\n\n  free(internal = false) {\n    assert(!!this[DATA].wrapper,\n      'Cant free struct, either: unallocated / already freed / sub-struct');\n\n    // frees any pointers contained in the struct\n    const freePointers = (struct) => {\n      struct.constructor.fields.forEach((field, name) => {\n        if (field.type.isPointer) struct[name].free();\n        if (field.type.isStruct) freePointers(struct[name]);\n      });\n    };\n\n    if (internal) freePointers(this);\n\n    this[DATA].wrapper.free(this.ref(), this.constructor.width);\n    this[DATA].wrapper = null;\n    this[DATA].view = null;\n  }\n\n  toString() {\n    let out = '{\\n';\n\n    const stringify = (struct) => {\n      const fields = struct.constructor.fields;\n      const proto = struct.constructor.prototype;\n\n      fields.forEach((field, name) => {\n        out += `  ${name}: ${struct[name]},\\n`;\n      });\n\n      Object.getOwnPropertyNames(proto).forEach((name) => {\n        if (fields.has(name)) return;\n\n        const value = struct[name];\n\n        if (typeof value !== 'function') {\n          out += `  ${name}: ${value},\\n`;\n        }\n      });\n    };\n\n    stringify(this);\n\n    if (out.length <= 80) {\n      out = out.replace(/\\n/g, '')    // remove line breaks\n               .replace(/ {2}/g, ' ') // collapse whitespace\n               .replace(/,$/g, ' ');  // trailing comma\n    }\n\n    out += '}';\n\n    return out;\n  }\n\n  dataview(name) {\n    const view = this[DATA].view;\n    assert(!!view, \"Struct hasn't been written yet, can't get dataview\");\n\n    if (!name) return view;\n\n    const StructType = this.constructor;\n    const field = StructType.fields.get(name);\n    assert(!!field, `Field '${name}' doesn't exist on struct`);\n\n    return vslice(view, field.offset, field.type.width);\n  }\n\n  static read(view, wrapper) {\n    const StructType = this;\n\n    const struct = new StructType();\n    struct[DATA].view = view;\n    struct[DATA].wrapper = wrapper;\n\n    return struct;\n  }\n\n  static write(view, struct, wrapper) {\n    const StructType = this;\n\n    if (isNil(struct) || !struct.constructor.isStruct) {\n      struct = new StructType(struct);\n    }\n\n    StructType.fields.forEach((field, name) => {\n      const type = field.type;\n      let value = struct[name];\n\n      if (typeof value !== 'undefined') {\n        if (type.isStruct && (isNil(value) || !value.constructor.isStruct)) {\n          value = new type(value);\n        }\n\n        const fieldView = vslice(view, field.offset, type.width);\n        type.write(fieldView, value, wrapper);\n      }\n    });\n\n    struct[DATA].view = view;\n    struct[DATA].wrapper = wrapper;\n  }\n}\n\n\n// Creates a new class that will create new struct instances\n// (this returns a constructor)\nclass Struct {\n  constructor(fields = {}, opt = {}) {\n    // preserve field insertion order with [[OwnPropertyKeys]]\n    const names = Object.getOwnPropertyNames(fields);\n\n    // check for field name conflicts\n    ['ref', 'free', 'dataview'].forEach(name =>\n      assert(!(names in names), `Field '${name}' is a reserved method name`));\n\n    // keep metadata on the constructor itself\n    class StructType extends AbstractStructType {}\n    StructType.fields = new Map();\n    StructType.packed = ('packed' in opt) ? !!opt.packed : false;\n    StructType.alignment = opt.alignment || 0;\n    StructType.isStruct = true;\n\n    let offset = 0;\n\n    // get type/size/alignment for each field\n    names.forEach((name) => {\n      const type = parseType(fields[name]);\n\n      if (!opt.alignment && type.alignment > StructType.alignment) {\n        StructType.alignment = type.alignment;\n      }\n\n      if (!StructType.packed && offset % type.alignment !== 0) {\n        offset += type.alignment - (offset % type.alignment);\n      }\n\n      StructType.fields.set(name, { name, offset, type });\n      offset += type.width;\n    });\n\n    StructType.width = (offset % StructType.alignment)\n      ? offset + StructType.alignment - (offset % StructType.alignment)\n      : offset;\n\n    // define getter / setter behavior for each field\n    // these will read / write each field to memory according to its type\n    StructType.fields.forEach((field, name) => {\n      Object.defineProperty(StructType.prototype, name, {\n        enumerable: true,\n\n        get() {\n          if (!this[DATA].view) {\n            return this[DATA].temp[name];\n          }\n\n          const view = vslice(this[DATA].view, field.offset, field.type.width);\n          return field.type.read(view, this[DATA].wrapper);\n        },\n\n        set(value) {\n          if (!this[DATA].view) {\n            this[DATA].temp[name] = value;\n            return;\n          }\n\n          const view = vslice(this[DATA].view, field.offset, field.type.width);\n          field.type.write(view, value, this[DATA].wrapper);\n        },\n      });\n    });\n\n    return StructType;\n  }\n}\n\n\nexport default Struct;\n","import Struct from './Struct';\nimport { types, parseType, Pointer } from './types';\nimport { encode, decode } from './encoding';\nimport { assert, vslice, isNil, addStringFns, addArrayFns, makeIterable } from './misc';\n\n\n// get the symbol for struct-data since we need access here\nconst DATA = (typeof Symbol !== 'undefined')\n  ? Symbol.for('struct-data')\n  : '__data';\n\n\nfunction RustTuple(tupleTypes, values) {\n  const fields = {};\n\n  tupleTypes.forEach((type, i) => {\n    fields[i] = parseType(type);\n  });\n\n  const Tuple = new Struct(fields);\n\n  return (values)\n    ? new Tuple(values)\n    : Tuple;\n}\n\n\nfunction RustVector(typedef, initialValues) {\n  const type = parseType(typedef);\n\n  const Base = new Struct({\n    ptr: types.pointer(type),\n    cap: 'usize',\n    length: 'usize',\n    /* values */\n  });\n\n  Object.defineProperty(Base.prototype, 'values', {\n    enumerable: true,\n\n    get() {\n      const memory = this[DATA].view.buffer;\n      const wrapper = this[DATA].wrapper;\n\n      const arrayType = parseType([type, this.length]);\n      const view = new DataView(memory, this.ptr.ref(), arrayType.width);\n\n      return arrayType.read(view, wrapper);\n    },\n\n    set(values) {\n      this.ptr = new Pointer([type, values.length], values);\n      this.length = values.length;\n      this.cap = values.length;\n    },\n  });\n\n  addArrayFns(Base);\n  makeIterable(Base);\n\n  class Vector extends Base {\n    constructor(values) {\n      super();\n      if (values) this.values = values;\n    }\n\n    free() {\n      super.free(true); // free ptr data\n    }\n  }\n\n  return (initialValues)\n    ? new Vector(initialValues)\n    : Vector;\n}\n\n\nfunction RustSlice(typedef, initialValues) {\n  const type = parseType(typedef);\n\n  const Base = new Struct({\n    ptr: types.pointer(type),\n    length: 'usize',\n    /* values */\n  });\n\n  Object.defineProperty(Base.prototype, 'values', {\n    enumerable: true,\n\n    get() {\n      const memory = this[DATA].view.buffer;\n      const wrapper = this[DATA].wrapper;\n\n      const arrayType = parseType([type, this.length]);\n      const view = new DataView(memory, this.ptr.ref(), arrayType.width);\n\n      return arrayType.read(view, wrapper);\n    },\n\n    set(values) {\n      this.ptr = new Pointer([type, values.length], values);\n      this.length = values.length;\n    },\n  });\n\n  addArrayFns(Base);\n  makeIterable(Base);\n\n  class Slice extends Base {\n    constructor(values) {\n      super();\n      if (values) this.values = values;\n    }\n\n    free() {\n      super.free(true); // free ptr data\n    }\n  }\n\n  return (initialValues)\n    ? new Slice(initialValues)\n    : Slice;\n}\n\n\nfunction RustString() {\n  const Base = new Struct({\n    ptr: types.pointer('u8'),\n    length: 'usize',\n    cap: 'usize',\n    /* value */\n  });\n\n  Object.defineProperty(Base.prototype, 'value', {\n    enumerable: true,\n\n    get() {\n      const memory = this[DATA].view.buffer;\n      const buf = new Uint8Array(memory, this.ptr.ref(), this.length);\n\n      return decode(buf);\n    },\n\n    set(str) {\n      const buf = encode(str);\n\n      this.ptr = new Pointer(['u8', buf.length], buf);\n      this.length = buf.length;\n      this.cap    = buf.length;\n    },\n  });\n\n  addStringFns(Base);\n\n  class _RustString extends Base {\n    constructor(value) {\n      super();\n      if (value) this.value = value;\n    }\n\n    free() {\n      super.free(true); // free ptr data\n    }\n  }\n\n  return _RustString;\n}\n\n\nfunction RustStr() {\n  const Base = new Struct({\n    ptr: types.pointer('u8'),\n    length: 'usize',\n    /* value */\n  });\n\n  Object.defineProperty(Base.prototype, 'value', {\n    enumerable: true,\n\n    get() {\n      const memory = this[DATA].view.buffer;\n      const buf = new Uint8Array(memory, this.ptr.ref(), this.length);\n\n      return decode(buf);\n    },\n\n    set(str) {\n      const buf = encode(str);\n\n      this.ptr = new Pointer(['u8', buf.length], buf);\n      this.length = buf.length;\n    },\n  });\n\n  addStringFns(Base);\n\n  class _RustStr extends Base {\n    constructor(value) {\n      super();\n      if (value) this.value = value;\n    }\n\n    free() {\n      super.free(true); // free ptr data\n    }\n  }\n\n  return _RustStr;\n}\n\n\nfunction RustOption(typedef, isNonNullable = false, tagSize) {\n  const type = parseType(typedef);\n  let discriminant;\n\n  if (tagSize) discriminant = types[`uint${tagSize * 8}`];\n  else if (type.alignment === 1) discriminant = 'uint8';\n  else if (type.alignment === 2) discriminant = 'uint16';\n  else discriminant = 'uint32';\n\n  const fields = (isNonNullable)\n    ? { value: type }\n    : { discriminant, value: type };\n\n  const Base = new Struct(fields);\n\n  class OptionType extends Base {\n    constructor(value) {\n      super();\n      this.value = value;\n      this.discriminant = (isNil(value)) ? 0 : 1;\n    }\n\n    static some(value) {\n      return new OptionType(value);\n    }\n\n    static none() {\n      return new OptionType();\n    }\n\n    isSome() {\n      return ('discriminant' in fields) ? !!this.discriminant : !!this.value;\n    }\n\n    isNone() {\n      return !this.isSome();\n    }\n\n    expect(msg) {\n      if (!this.isSome()) throw new Error(msg);\n      return this.value;\n    }\n\n    unwrap() {\n      if (!this.isSome()) throw new Error('Error unwrapping none');\n      return this.value;\n    }\n\n    unwrapOr(defaultValue) {\n      return (this.isSome()) ? this.value : defaultValue;\n    }\n\n    unwrapOrElse(fn) {\n      return (this.isSome()) ? this.value : fn();\n    }\n  }\n\n  return OptionType;\n}\n\n\nfunction RustEnum(obj, tagSize = 4) {\n  const variants = Object.getOwnPropertyNames(obj);\n  const vtypes = variants.map(name => parseType(obj[name]));\n  const discriminant = types[`uint${tagSize * 8}`];\n\n  const StructType = new Struct({\n    discriminant,\n    /* value */\n  });\n\n  class Enum extends StructType {\n    constructor(variant) {\n      super();\n      if (variant) this._set(variant);\n    }\n\n    _set(variant) {\n      assert(Object.keys(variant).length === 1, 'Enum value must be a variant');\n\n      const [name, value] = Object.entries(variant)[0];\n\n      this.discriminant = variants.indexOf(name);\n      this.value = value;\n    }\n\n    tag() {\n      const tag = this.discriminant;\n      assert(tag <= variants.length, 'Enum discriminant > than # of variants');\n      return tag;\n    }\n\n    free(internal = false) {\n      const type = vtypes[this.tag()];\n\n      if (internal && type.isPointer || type.isStruct) {\n        this.value.free(internal);\n      }\n\n      this[DATA].wrapper.free(this.ref(), Enum.width);\n      this[DATA].wrapper = null;\n      this[DATA].view = null;\n    }\n\n    name() {\n      return variants[this.tag()];\n    }\n\n    is(name) {\n      return (variants.indexOf(name) === this.tag());\n    }\n\n    match(arms) {\n      const name = variants[this.tag()];\n      const val = this.value;\n\n      if (name in arms) {\n        return (typeof arms[name] === 'function') ? arms[name](val) : arms[name];\n      }\n\n      if ('_' in arms) {\n        return (typeof arms._ === 'function') ? arms._(val) : arms._;\n      }\n    }\n\n    static write(view, struct, wrapper) {\n      if (isNil(struct) || !struct.constructor.isStruct) {\n        struct = new Enum(struct);\n      }\n\n      const tag = struct.tag();\n      const type = vtypes[tag];\n      let value = (struct.ref()) ? struct.value : struct[DATA].temp.value;\n\n      if (type.isStruct && (isNil(value) || !value.constructor.isStruct)) {\n        value = new type(value);\n      }\n\n      const field_1 = vslice(view, 0, discriminant.width);\n      discriminant.write(field_1, tag);\n\n      const field_2 = vslice(view, discriminant.width, type.width);\n      type.write(field_2, value, wrapper);\n\n      struct[DATA].view = view;\n      struct[DATA].wrapper = wrapper;\n    }\n  }\n\n  Object.defineProperty(Enum.prototype, 'value', {\n    enumerable: true,\n\n    get() {\n      const memory = this[DATA].view.buffer;\n      const wrapper = this[DATA].wrapper;\n\n      const type = vtypes[this.tag()];\n      const addr = this.ref() + discriminant.width;\n      const view = new DataView(memory, addr, type.width);\n\n      return type.read(view, wrapper);\n    },\n\n    set(value) {\n      this[DATA].temp.value = value;\n    },\n  });\n\n  const width = discriminant.width + Math.max(...vtypes.map(t => t.width));\n  const align = Math.max(...vtypes.map(t => t.alignment), discriminant.alignment);\n\n  Enum.width = (width % align)\n    ? width + align - (width % align)\n    : width;\n\n  return Enum;\n}\n\n\nconst rust = {\n  tuple:  RustTuple,\n  vector: RustVector,\n  slice:  RustSlice,\n  string: RustString(),\n  str:    RustStr(),\n  enum:   RustEnum,\n  option: RustOption,\n\n  some: function ctor(type, value, ...opts) {\n    return new (RustOption(type, ...opts))(value);\n  },\n  none: function ctor(type, ...opts) {\n    return new (RustOption(type, ...opts))();\n  },\n\n  // deprecated\n  Tuple: RustTuple,\n  Vector: RustVector,\n  Slice: RustSlice,\n  String: RustString(),\n  Str: RustStr(),\n  Option: function ctor(type, value, ...opts) {\n    return new (RustOption(type, ...opts))(value);\n  },\n  Some: function ctor(type, value, ...opts) {\n    return new (RustOption(type, ...opts))(value);\n  },\n  None: function ctor(type, ...opts) {\n    return new (RustOption(type, ...opts))();\n  },\n};\n\n\nexport default rust;\n","import Struct from './Struct';\nimport { types, parseType, Pointer } from './types';\nimport { addArrayFns, makeIterable } from './misc';\n\n\n// get the symbol for struct-data since we need access here\nconst DATA = (typeof Symbol !== 'undefined')\n  ? Symbol.for('struct-data')\n  : '__data';\n\n\nfunction ASArrayBuffer(typedef, n) {\n  const type = parseType(typedef);\n\n  return new Struct({\n    byteLength: 'usize',\n    _:          'usize', // allocator alignment?\n    values:     [type, n],\n  });\n}\n\n\nfunction ASArray(typedef, initialValues) {\n  const type = parseType(typedef);\n\n  const Base = new Struct({\n    ptr: types.pointer('void'),\n    length: 'usize',\n    /* buffer */\n    /* values */\n  });\n\n  Object.defineProperty(Base.prototype, 'buffer', {\n    enumerable: true,\n\n    get() {\n      const memory = this[DATA].view.buffer;\n      const wrapper = this[DATA].wrapper;\n\n      const AB = new ASArrayBuffer(type, this.length);\n      const view = new DataView(memory, this.ptr.ref(), AB.width);\n\n      return AB.read(view, wrapper);\n    },\n  });\n\n  Object.defineProperty(Base.prototype, 'values', {\n    enumerable: true,\n\n    get() {\n      return this.buffer.values;\n    },\n\n    set(values) {\n      const n = values.length;\n      const byteLength = n * type.width;\n\n      const AB = new ASArrayBuffer(type, n);\n      const buf = new AB({ byteLength, values });\n\n      this.ptr = new Pointer(AB, buf);\n      this.length = n;\n    },\n  });\n\n  addArrayFns(Base);\n  makeIterable(Base);\n\n  class _Array extends Base {\n    constructor(values) {\n      super();\n      if (values) this.values = values;\n    }\n\n    free() {\n      super.free(true); // free buffer_ too\n    }\n\n    dataview(field) {\n      if (field === 'buffer') return this.buffer.dataview();\n      if (field === 'values') return this.buffer.dataview('values');\n\n      return super.dataview(field);\n    }\n  }\n\n  return (initialValues)\n    ? new _Array(initialValues)\n    : _Array;\n}\n\n\nexport default {\n  array: ASArray,\n};\n","import { Wrapper, cwrap, ccall } from './Wrapper';\nimport Struct from './Struct';\nimport demangle from './demangle';\nimport rust from './rust';\nimport assemblyscript from './assemblyscript';\nimport { types, Pointer, StringPointer, CustomType } from './types';\n\nimport { encodeUTF8, decodeUTF8 } from './encoding';\nconst _encodeUTF8 = encodeUTF8;\nconst _decodeUTF8 = decodeUTF8;\n\nconst CString = StringPointer;\n\nexport default {\n  Wrapper,\n  cwrap,\n  ccall,\n  Struct,\n  types,\n  CustomType,\n  Pointer,\n  StringPointer,\n  CString, // deprecated\n  demangle,\n  rust,\n  assemblyscript,\n  _encodeUTF8,\n  _decodeUTF8,\n};\n\nexport {\n  Wrapper,\n  cwrap,\n  ccall,\n  Struct,\n  types,\n  CustomType,\n  Pointer,\n  StringPointer,\n  CString, // deprecated\n  demangle,\n  rust,\n  assemblyscript,\n  _encodeUTF8,\n  _decodeUTF8,\n};\n","import { Wrapper, rust } from 'wasm-ffi';\n\n// const wasmURL = 'web.wasm';\nconst wasmURL = process.env.ENCRUSTEDROOT + \"web.wasm\"\nconsole.log('wasmURL ', wasmURL)\n\n// hold onto active file in case of restarts\nlet file = null;\n\n\nfunction sendWorkerMessage(type, msg) {\n  postMessage({ type, msg });\n}\n\n\nconst zmachine = new Wrapper({\n  create: [null, ['number', 'number']],\n  feed: [null, ['string']],\n  step: ['bool'],\n  undo: ['bool'],\n  redo: ['bool'],\n  get_updates: [],\n  restore: [null, ['string']],\n  load_savestate: [null, ['string']],\n  enable_instruction_logs: [null, ['bool']],\n  get_object_details: [rust.string, ['number']],\n  flush_log: [],\n});\n\n\nzmachine.imports(wrap => ({\n  env: {\n    js_message: wrap('string', 'string', sendWorkerMessage),\n\n    trace: wrap('string', (msg) => {\n      const err = new Error(msg);\n\n      setTimeout(() => {\n        zmachine.flush_log();\n      }, 200);\n\n      postMessage({\n        type: 'error',\n        msg: { msg, stack: err.stack }\n      });\n    }),\n\n    rand: function() {\n      return Math.floor(Math.random() * 0xFFFF);\n    }\n  },\n}));\n\n\nfunction step() {\n  const done = zmachine.step();\n  if (done) sendWorkerMessage('quit');\n}\n\n\nfunction instantiate() {\n  if (zmachine.exports) return Promise.resolve();\n  return zmachine.fetch(wasmURL);\n}\n\n\n// dispatch handlers based on incoming messages\nonmessage = (ev) => {\n  // only want to compile/load the module once\n  if (ev.data.type === 'instantiate') {\n    instantiate().catch(err => setTimeout(() => {\n      console.log('Error starting wasm: ', err, err.stack);\n    }));\n  }\n\n  if (ev.data.type === 'load') {\n    instantiate()\n      .then(() => {\n        file = new Uint8Array(ev.data.msg.file);\n        const file_ptr = zmachine.utils.writeArray(file);\n\n        zmachine.create(file_ptr, file.length);\n        sendWorkerMessage('loaded');\n      })\n      .catch(err => setTimeout(() => {\n        console.log('Error starting wasm: ', err, err.stack);\n      }));\n  }\n\n  if (ev.data.type === 'start') {\n    step();\n  }\n\n  if (ev.data.type === 'restart') {\n    const file_ptr = zmachine.utils.writeArray(file);\n\n    zmachine.create(file_ptr, file.length);\n    sendWorkerMessage('loaded');\n  }\n\n  if (ev.data.type === 'input') {\n    zmachine.feed(ev.data.msg);\n    step();\n  }\n\n  if (ev.data.type === 'restore') {\n    zmachine.restore(ev.data.msg);\n    step();\n  }\n\n  if (ev.data.type === 'load_savestate') {\n    zmachine.load_savestate(ev.data.msg);\n    step();\n    zmachine.feed('look'); // get description text and then undo\n    step();\n    zmachine.undo();\n  }\n\n  if (ev.data.type === 'undo') {\n    const ok = zmachine.undo();\n\n    sendWorkerMessage('undo', ok);\n    zmachine.get_updates();\n  }\n\n  if (ev.data.type === 'redo') {\n    const ok = zmachine.redo();\n\n    sendWorkerMessage('redo', ok);\n    zmachine.get_updates();\n  }\n\n  if (ev.data.type === 'enable:instructions') {\n    zmachine.enable_instruction_logs(!!ev.data.msg);\n  }\n\n  if (ev.data.type === 'getDetails') {\n    const str = zmachine.get_object_details(ev.data.msg);\n    sendWorkerMessage('getDetails', str.value);\n    str.free();\n  }\n};\n"],"sourceRoot":""}